<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>test\qunit\vendor\qunit.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: test\qunit\vendor\qunit.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * QUnit 1.2.0pre - A JavaScript Unit Testing Framework
 *
 * http:&#x2F;&#x2F;docs.jquery.com&#x2F;QUnit
 *
 * Copyright (c) 2011 John Resig, Jörn Zaefferer
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * or GPL (GPL-LICENSE.txt) licenses.
 * Pulled Live from Git Mon Oct 31 14:00:02 UTC 2011
 * Last Commit: ee156923cdb01820e35e6bb579d5cf6bf55736d4
 *&#x2F;

(function(window) {

var defined = {
	setTimeout: typeof window.setTimeout !== &quot;undefined&quot;,
	sessionStorage: (function() {
		try {
			return !!sessionStorage.getItem;
		} catch(e) {
			return false;
		}
	})()
};

var	testId = 0,
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty;

var Test = function(name, testName, expected, testEnvironmentArg, async, callback) {
	this.name = name;
	this.testName = testName;
	this.expected = expected;
	this.testEnvironmentArg = testEnvironmentArg;
	this.async = async;
	this.callback = callback;
	this.assertions = [];
};
Test.prototype = {
	init: function() {
		var tests = id(&quot;qunit-tests&quot;);
		if (tests) {
			var b = document.createElement(&quot;strong&quot;);
				b.innerHTML = &quot;Running &quot; + this.name;
			var li = document.createElement(&quot;li&quot;);
				li.appendChild( b );
				li.className = &quot;running&quot;;
				li.id = this.id = &quot;test-output&quot; + testId++;
			tests.appendChild( li );
		}
	},
	setup: function() {
		if (this.module != config.previousModule) {
			if ( config.previousModule ) {
				runLoggingCallbacks(&#x27;moduleDone&#x27;, QUnit, {
					name: config.previousModule,
					failed: config.moduleStats.bad,
					passed: config.moduleStats.all - config.moduleStats.bad,
					total: config.moduleStats.all
				} );
			}
			config.previousModule = this.module;
			config.moduleStats = { all: 0, bad: 0 };
			runLoggingCallbacks( &#x27;moduleStart&#x27;, QUnit, {
				name: this.module
			} );
		}

		config.current = this;
		this.testEnvironment = extend({
			setup: function() {},
			teardown: function() {}
		}, this.moduleTestEnvironment);
		if (this.testEnvironmentArg) {
			extend(this.testEnvironment, this.testEnvironmentArg);
		}

		runLoggingCallbacks( &#x27;testStart&#x27;, QUnit, {
			name: this.testName,
			module: this.module
		});

		&#x2F;&#x2F; allow utility functions to access the current test environment
		&#x2F;&#x2F; TODO why??
		QUnit.current_testEnvironment = this.testEnvironment;

		try {
			if ( !config.pollution ) {
				saveGlobal();
			}

			this.testEnvironment.setup.call(this.testEnvironment);
		} catch(e) {
			QUnit.ok( false, &quot;Setup failed on &quot; + this.testName + &quot;: &quot; + e.message );
		}
	},
	run: function() {
		config.current = this;
		if ( this.async ) {
			QUnit.stop();
		}

		if ( config.notrycatch ) {
			this.callback.call(this.testEnvironment);
			return;
		}
		try {
			this.callback.call(this.testEnvironment);
		} catch(e) {
			fail(&quot;Test &quot; + this.testName + &quot; died, exception and test follows&quot;, e, this.callback);
			QUnit.ok( false, &quot;Died on test #&quot; + (this.assertions.length + 1) + &quot;: &quot; + e.message + &quot; - &quot; + QUnit.jsDump.parse(e) );
			&#x2F;&#x2F; else next test will carry the responsibility
			saveGlobal();

			&#x2F;&#x2F; Restart the tests if they&#x27;re blocking
			if ( config.blocking ) {
				QUnit.start();
			}
		}
	},
	teardown: function() {
		config.current = this;
		try {
			this.testEnvironment.teardown.call(this.testEnvironment);
			checkPollution();
		} catch(e) {
			QUnit.ok( false, &quot;Teardown failed on &quot; + this.testName + &quot;: &quot; + e.message );
		}
	},
	finish: function() {
		config.current = this;
		if ( this.expected != null &amp;&amp; this.expected != this.assertions.length ) {
			QUnit.ok( false, &quot;Expected &quot; + this.expected + &quot; assertions, but &quot; + this.assertions.length + &quot; were run&quot; );
		}

		var good = 0, bad = 0,
			tests = id(&quot;qunit-tests&quot;);

		config.stats.all += this.assertions.length;
		config.moduleStats.all += this.assertions.length;

		if ( tests ) {
			var ol = document.createElement(&quot;ol&quot;);

			for ( var i = 0; i &lt; this.assertions.length; i++ ) {
				var assertion = this.assertions[i];

				var li = document.createElement(&quot;li&quot;);
				li.className = assertion.result ? &quot;pass&quot; : &quot;fail&quot;;
				li.innerHTML = assertion.message || (assertion.result ? &quot;okay&quot; : &quot;failed&quot;);
				ol.appendChild( li );

				if ( assertion.result ) {
					good++;
				} else {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}

			&#x2F;&#x2F; store result when possible
			if ( QUnit.config.reorder &amp;&amp; defined.sessionStorage ) {
				if (bad) {
					sessionStorage.setItem(&quot;qunit-&quot; + this.module + &quot;-&quot; + this.testName, bad);
				} else {
					sessionStorage.removeItem(&quot;qunit-&quot; + this.module + &quot;-&quot; + this.testName);
				}
			}

			if (bad == 0) {
				ol.style.display = &quot;none&quot;;
			}

			var b = document.createElement(&quot;strong&quot;);
			b.innerHTML = this.name + &quot; &lt;b class=&#x27;counts&#x27;&gt;(&lt;b class=&#x27;failed&#x27;&gt;&quot; + bad + &quot;&lt;&#x2F;b&gt;, &lt;b class=&#x27;passed&#x27;&gt;&quot; + good + &quot;&lt;&#x2F;b&gt;, &quot; + this.assertions.length + &quot;)&lt;&#x2F;b&gt;&quot;;

			var a = document.createElement(&quot;a&quot;);
			a.innerHTML = &quot;Rerun&quot;;
			a.href = QUnit.url({ filter: getText([b]).replace(&#x2F;\([^)]+\)$&#x2F;, &quot;&quot;).replace(&#x2F;(^\s*|\s*$)&#x2F;g, &quot;&quot;) });

			addEvent(b, &quot;click&quot;, function() {
				var next = b.nextSibling.nextSibling,
					display = next.style.display;
				next.style.display = display === &quot;none&quot; ? &quot;block&quot; : &quot;none&quot;;
			});

			addEvent(b, &quot;dblclick&quot;, function(e) {
				var target = e &amp;&amp; e.target ? e.target : window.event.srcElement;
				if ( target.nodeName.toLowerCase() == &quot;span&quot; || target.nodeName.toLowerCase() == &quot;b&quot; ) {
					target = target.parentNode;
				}
				if ( window.location &amp;&amp; target.nodeName.toLowerCase() === &quot;strong&quot; ) {
					window.location = QUnit.url({ filter: getText([target]).replace(&#x2F;\([^)]+\)$&#x2F;, &quot;&quot;).replace(&#x2F;(^\s*|\s*$)&#x2F;g, &quot;&quot;) });
				}
			});

			var li = id(this.id);
			li.className = bad ? &quot;fail&quot; : &quot;pass&quot;;
			li.removeChild( li.firstChild );
			li.appendChild( b );
			li.appendChild( a );
			li.appendChild( ol );

		} else {
			for ( var i = 0; i &lt; this.assertions.length; i++ ) {
				if ( !this.assertions[i].result ) {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}
		}

		try {
			QUnit.reset();
		} catch(e) {
			fail(&quot;reset() failed, following Test &quot; + this.testName + &quot;, exception and reset fn follows&quot;, e, QUnit.reset);
		}

		runLoggingCallbacks( &#x27;testDone&#x27;, QUnit, {
			name: this.testName,
			module: this.module,
			failed: bad,
			passed: this.assertions.length - bad,
			total: this.assertions.length
		} );
	},

	queue: function() {
		var test = this;
		synchronize(function() {
			test.init();
		});
		function run() {
			&#x2F;&#x2F; each of these can by async
			synchronize(function() {
				test.setup();
			});
			synchronize(function() {
				test.run();
			});
			synchronize(function() {
				test.teardown();
			});
			synchronize(function() {
				test.finish();
			});
		}
		&#x2F;&#x2F; defer when previous test run passed, if storage is available
		var bad = QUnit.config.reorder &amp;&amp; defined.sessionStorage &amp;&amp; +sessionStorage.getItem(&quot;qunit-&quot; + this.module + &quot;-&quot; + this.testName);
		if (bad) {
			run();
		} else {
			synchronize(run, true);
		};
	}

};

var QUnit = {

	&#x2F;&#x2F; call on start of module test to prepend name to all tests
	module: function(name, testEnvironment) {
		config.currentModule = name;
		config.currentModuleTestEnviroment = testEnvironment;
	},

	asyncTest: function(testName, expected, callback) {
		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}

		QUnit.test(testName, expected, callback, true);
	},

	test: function(testName, expected, callback, async) {
		var name = &#x27;&lt;span class=&quot;test-name&quot;&gt;&#x27; + testName + &#x27;&lt;&#x2F;span&gt;&#x27;, testEnvironmentArg;

		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}
		&#x2F;&#x2F; is 2nd argument a testEnvironment?
		if ( expected &amp;&amp; typeof expected === &#x27;object&#x27;) {
			testEnvironmentArg = expected;
			expected = null;
		}

		if ( config.currentModule ) {
			name = &#x27;&lt;span class=&quot;module-name&quot;&gt;&#x27; + config.currentModule + &quot;&lt;&#x2F;span&gt;: &quot; + name;
		}

		if ( !validTest(config.currentModule + &quot;: &quot; + testName) ) {
			return;
		}

		var test = new Test(name, testName, expected, testEnvironmentArg, async, callback);
		test.module = config.currentModule;
		test.moduleTestEnvironment = config.currentModuleTestEnviroment;
		test.queue();
	},

	&#x2F;**
	 * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don&#x27;t slip through.
	 *&#x2F;
	expect: function(asserts) {
		config.current.expected = asserts;
	},

	&#x2F;**
	 * Asserts true.
	 * @example ok( &quot;asdfasdf&quot;.length &gt; 5, &quot;There must be at least 5 chars&quot; );
	 *&#x2F;
	ok: function(a, msg) {
		a = !!a;
		var details = {
			result: a,
			message: msg
		};
		msg = escapeInnerText(msg);
		runLoggingCallbacks( &#x27;log&#x27;, QUnit, details );
		config.current.assertions.push({
			result: a,
			message: msg
		});
	},

	&#x2F;**
	 * Checks that the first two arguments are equal, with an optional message.
	 * Prints out both actual and expected values.
	 *
	 * Prefered to ok( actual == expected, message )
	 *
	 * @example equal( format(&quot;Received {0} bytes.&quot;, 2), &quot;Received 2 bytes.&quot; );
	 *
	 * @param Object actual
	 * @param Object expected
	 * @param String message (optional)
	 *&#x2F;
	equal: function(actual, expected, message) {
		QUnit.push(expected == actual, actual, expected, message);
	},

	notEqual: function(actual, expected, message) {
		QUnit.push(expected != actual, actual, expected, message);
	},

	deepEqual: function(actual, expected, message) {
		QUnit.push(QUnit.equiv(actual, expected), actual, expected, message);
	},

	notDeepEqual: function(actual, expected, message) {
		QUnit.push(!QUnit.equiv(actual, expected), actual, expected, message);
	},

	strictEqual: function(actual, expected, message) {
		QUnit.push(expected === actual, actual, expected, message);
	},

	notStrictEqual: function(actual, expected, message) {
		QUnit.push(expected !== actual, actual, expected, message);
	},

	raises: function(block, expected, message) {
		var actual, ok = false;

		if (typeof expected === &#x27;string&#x27;) {
			message = expected;
			expected = null;
		}

		try {
			block();
		} catch (e) {
			actual = e;
		}

		if (actual) {
			&#x2F;&#x2F; we don&#x27;t want to validate thrown error
			if (!expected) {
				ok = true;
			&#x2F;&#x2F; expected is a regexp
			} else if (QUnit.objectType(expected) === &quot;regexp&quot;) {
				ok = expected.test(actual);
			&#x2F;&#x2F; expected is a constructor
			} else if (actual instanceof expected) {
				ok = true;
			&#x2F;&#x2F; expected is a validation function which returns true is validation passed
			} else if (expected.call({}, actual) === true) {
				ok = true;
			}
		}

		QUnit.ok(ok, message);
	},

	start: function(count) {
		config.semaphore -= count || 1;
		if (config.semaphore &gt; 0) {
			&#x2F;&#x2F; don&#x27;t start until equal number of stop-calls
			return;
		}
		if (config.semaphore &lt; 0) {
			&#x2F;&#x2F; ignore if start is called more often then stop
			config.semaphore = 0;
		}
		&#x2F;&#x2F; A slight delay, to avoid any current callbacks
		if ( defined.setTimeout ) {
			window.setTimeout(function() {
				if (config.semaphore &gt; 0) {
					return;
				}
				if ( config.timeout ) {
					clearTimeout(config.timeout);
				}

				config.blocking = false;
				process(true);
			}, 13);
		} else {
			config.blocking = false;
			process(true);
		}
	},

	stop: function(count) {
		config.semaphore += count || 1;
		config.blocking = true;

		if ( config.testTimeout &amp;&amp; defined.setTimeout ) {
			clearTimeout(config.timeout);
			config.timeout = window.setTimeout(function() {
				QUnit.ok( false, &quot;Test timed out&quot; );
				config.semaphore = 1;
				QUnit.start();
			}, config.testTimeout);
		}
	}
};

&#x2F;&#x2F;We want access to the constructor&#x27;s prototype
(function() {
	function F(){};
	F.prototype = QUnit;
	QUnit = new F();
	&#x2F;&#x2F;Make F QUnit&#x27;s constructor so that we can add to the prototype later
	QUnit.constructor = F;
})();

&#x2F;&#x2F; Backwards compatibility, deprecated
QUnit.equals = QUnit.equal;
QUnit.same = QUnit.deepEqual;

&#x2F;&#x2F; Maintain internal state
var config = {
	&#x2F;&#x2F; The queue of tests to run
	queue: [],

	&#x2F;&#x2F; block until document ready
	blocking: true,

	&#x2F;&#x2F; when enabled, show only failing tests
	&#x2F;&#x2F; gets persisted through sessionStorage and can be changed in UI via checkbox
	hidepassed: false,

	&#x2F;&#x2F; by default, run previously failed tests first
	&#x2F;&#x2F; very useful in combination with &quot;Hide passed tests&quot; checked
	reorder: true,

	&#x2F;&#x2F; by default, modify document.title when suite is done
	altertitle: true,

	urlConfig: [&#x27;noglobals&#x27;, &#x27;notrycatch&#x27;],

	&#x2F;&#x2F;logging callback queues
	begin: [],
	done: [],
	log: [],
	testStart: [],
	testDone: [],
	moduleStart: [],
	moduleDone: []
};

&#x2F;&#x2F; Load paramaters
(function() {
	var location = window.location || { search: &quot;&quot;, protocol: &quot;file:&quot; },
		params = location.search.slice( 1 ).split( &quot;&amp;&quot; ),
		length = params.length,
		urlParams = {},
		current;

	if ( params[ 0 ] ) {
		for ( var i = 0; i &lt; length; i++ ) {
			current = params[ i ].split( &quot;=&quot; );
			current[ 0 ] = decodeURIComponent( current[ 0 ] );
			&#x2F;&#x2F; allow just a key to turn on a flag, e.g., test.html?noglobals
			current[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;
			urlParams[ current[ 0 ] ] = current[ 1 ];
		}
	}

	QUnit.urlParams = urlParams;
	config.filter = urlParams.filter;

	&#x2F;&#x2F; Figure out if we&#x27;re running the tests from a server or not
	QUnit.isLocal = !!(location.protocol === &#x27;file:&#x27;);
})();

&#x2F;&#x2F; Expose the API as global variables, unless an &#x27;exports&#x27;
&#x2F;&#x2F; object exists, in that case we assume we&#x27;re in CommonJS
if ( typeof exports === &quot;undefined&quot; || typeof require === &quot;undefined&quot; ) {
	extend(window, QUnit);
	window.QUnit = QUnit;
} else {
	extend(exports, QUnit);
	exports.QUnit = QUnit;
}

&#x2F;&#x2F; define these after exposing globals to keep them in these QUnit namespace only
extend(QUnit, {
	config: config,

	&#x2F;&#x2F; Initialize the configuration options
	init: function() {
		extend(config, {
			stats: { all: 0, bad: 0 },
			moduleStats: { all: 0, bad: 0 },
			started: +new Date,
			updateRate: 1000,
			blocking: false,
			autostart: true,
			autorun: false,
			filter: &quot;&quot;,
			queue: [],
			semaphore: 0
		});

		var tests = id( &quot;qunit-tests&quot; ),
			banner = id( &quot;qunit-banner&quot; ),
			result = id( &quot;qunit-testresult&quot; );

		if ( tests ) {
			tests.innerHTML = &quot;&quot;;
		}

		if ( banner ) {
			banner.className = &quot;&quot;;
		}

		if ( result ) {
			result.parentNode.removeChild( result );
		}

		if ( tests ) {
			result = document.createElement( &quot;p&quot; );
			result.id = &quot;qunit-testresult&quot;;
			result.className = &quot;result&quot;;
			tests.parentNode.insertBefore( result, tests );
			result.innerHTML = &#x27;Running...&lt;br&#x2F;&gt;&amp;nbsp;&#x27;;
		}
	},

	&#x2F;**
	 * Resets the test setup. Useful for tests that modify the DOM.
	 *
	 * If jQuery is available, uses jQuery&#x27;s html(), otherwise just innerHTML.
	 *&#x2F;
	reset: function() {
		if ( window.jQuery ) {
			jQuery( &quot;#qunit-fixture&quot; ).html( config.fixture );
		} else {
			var main = id( &#x27;qunit-fixture&#x27; );
			if ( main ) {
				main.innerHTML = config.fixture;
			}
		}
	},

	&#x2F;**
	 * Trigger an event on an element.
	 *
	 * @example triggerEvent( document.body, &quot;click&quot; );
	 *
	 * @param DOMElement elem
	 * @param String type
	 *&#x2F;
	triggerEvent: function( elem, type, event ) {
		if ( document.createEvent ) {
			event = document.createEvent(&quot;MouseEvents&quot;);
			event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
				0, 0, 0, 0, 0, false, false, false, false, 0, null);
			elem.dispatchEvent( event );

		} else if ( elem.fireEvent ) {
			elem.fireEvent(&quot;on&quot;+type);
		}
	},

	&#x2F;&#x2F; Safe object type checking
	is: function( type, obj ) {
		return QUnit.objectType( obj ) == type;
	},

	objectType: function( obj ) {
		if (typeof obj === &quot;undefined&quot;) {
				return &quot;undefined&quot;;

		&#x2F;&#x2F; consider: typeof null === object
		}
		if (obj === null) {
				return &quot;null&quot;;
		}

		var type = toString.call( obj ).match(&#x2F;^\[object\s(.*)\]$&#x2F;)[1] || &#x27;&#x27;;

		switch (type) {
				case &#x27;Number&#x27;:
						if (isNaN(obj)) {
								return &quot;nan&quot;;
						} else {
								return &quot;number&quot;;
						}
				case &#x27;String&#x27;:
				case &#x27;Boolean&#x27;:
				case &#x27;Array&#x27;:
				case &#x27;Date&#x27;:
				case &#x27;RegExp&#x27;:
				case &#x27;Function&#x27;:
						return type.toLowerCase();
		}
		if (typeof obj === &quot;object&quot;) {
				return &quot;object&quot;;
		}
		return undefined;
	},

	push: function(result, actual, expected, message) {
		var details = {
			result: result,
			message: message,
			actual: actual,
			expected: expected
		};

		message = escapeInnerText(message) || (result ? &quot;okay&quot; : &quot;failed&quot;);
		message = &#x27;&lt;span class=&quot;test-message&quot;&gt;&#x27; + message + &quot;&lt;&#x2F;span&gt;&quot;;
		expected = escapeInnerText(QUnit.jsDump.parse(expected));
		actual = escapeInnerText(QUnit.jsDump.parse(actual));
		var output = message + &#x27;&lt;table&gt;&lt;tr class=&quot;test-expected&quot;&gt;&lt;th&gt;Expected: &lt;&#x2F;th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + expected + &#x27;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&#x27;;
		if (actual != expected) {
			output += &#x27;&lt;tr class=&quot;test-actual&quot;&gt;&lt;th&gt;Result: &lt;&#x2F;th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + actual + &#x27;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&#x27;;
			output += &#x27;&lt;tr class=&quot;test-diff&quot;&gt;&lt;th&gt;Diff: &lt;&#x2F;th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + QUnit.diff(expected, actual) +&#x27;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&#x27;;
		}
		if (!result) {
			var source = sourceFromStacktrace();
			if (source) {
				details.source = source;
				output += &#x27;&lt;tr class=&quot;test-source&quot;&gt;&lt;th&gt;Source: &lt;&#x2F;th&gt;&lt;td&gt;&lt;pre&gt;&#x27; + escapeInnerText(source) + &#x27;&lt;&#x2F;pre&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&#x27;;
			}
		}
		output += &quot;&lt;&#x2F;table&gt;&quot;;

		runLoggingCallbacks( &#x27;log&#x27;, QUnit, details );

		config.current.assertions.push({
			result: !!result,
			message: output
		});
	},

	url: function( params ) {
		params = extend( extend( {}, QUnit.urlParams ), params );
		var querystring = &quot;?&quot;,
			key;
		for ( key in params ) {
			if ( !hasOwn.call( params, key ) ) {
				continue;
			}
			querystring += encodeURIComponent( key ) + &quot;=&quot; +
				encodeURIComponent( params[ key ] ) + &quot;&amp;&quot;;
		}
		return window.location.pathname + querystring.slice( 0, -1 );
	},

	extend: extend,
	id: id,
	addEvent: addEvent
});

&#x2F;&#x2F;QUnit.constructor is set to the empty F() above so that we can add to it&#x27;s prototype later
&#x2F;&#x2F;Doing this allows us to tell if the following methods have been overwritten on the actual
&#x2F;&#x2F;QUnit object, which is a deprecated way of using the callbacks.
extend(QUnit.constructor.prototype, {
	&#x2F;&#x2F; Logging callbacks; all receive a single argument with the listed properties
	&#x2F;&#x2F; run test&#x2F;logs.html for any related changes
	begin: registerLoggingCallback(&#x27;begin&#x27;),
	&#x2F;&#x2F; done: { failed, passed, total, runtime }
	done: registerLoggingCallback(&#x27;done&#x27;),
	&#x2F;&#x2F; log: { result, actual, expected, message }
	log: registerLoggingCallback(&#x27;log&#x27;),
	&#x2F;&#x2F; testStart: { name }
	testStart: registerLoggingCallback(&#x27;testStart&#x27;),
	&#x2F;&#x2F; testDone: { name, failed, passed, total }
	testDone: registerLoggingCallback(&#x27;testDone&#x27;),
	&#x2F;&#x2F; moduleStart: { name }
	moduleStart: registerLoggingCallback(&#x27;moduleStart&#x27;),
	&#x2F;&#x2F; moduleDone: { name, failed, passed, total }
	moduleDone: registerLoggingCallback(&#x27;moduleDone&#x27;)
});

if ( typeof document === &quot;undefined&quot; || document.readyState === &quot;complete&quot; ) {
	config.autorun = true;
}

QUnit.load = function() {
	runLoggingCallbacks( &#x27;begin&#x27;, QUnit, {} );

	&#x2F;&#x2F; Initialize the config, saving the execution queue
	var oldconfig = extend({}, config);
	QUnit.init();
	extend(config, oldconfig);

	config.blocking = false;

	var urlConfigHtml = &#x27;&#x27;, len = config.urlConfig.length;
	for ( var i = 0, val; i &lt; len, val = config.urlConfig[i]; i++ ) {
		config[val] = QUnit.urlParams[val];
		urlConfigHtml += &#x27;&lt;label&gt;&lt;input name=&quot;&#x27; + val + &#x27;&quot; type=&quot;checkbox&quot;&#x27; + ( config[val] ? &#x27; checked=&quot;checked&quot;&#x27; : &#x27;&#x27; ) + &#x27;&gt;&#x27; + val + &#x27;&lt;&#x2F;label&gt;&#x27;;
	}

	var userAgent = id(&quot;qunit-userAgent&quot;);
	if ( userAgent ) {
		userAgent.innerHTML = navigator.userAgent;
	}
	var banner = id(&quot;qunit-header&quot;);
	if ( banner ) {
		banner.innerHTML = &#x27;&lt;a href=&quot;&#x27; + QUnit.url({ filter: undefined }) + &#x27;&quot;&gt; &#x27; + banner.innerHTML + &#x27;&lt;&#x2F;a&gt; &#x27; + urlConfigHtml;
		addEvent( banner, &quot;change&quot;, function( event ) {
			var params = {};
			params[ event.target.name ] = event.target.checked ? true : undefined;
			window.location = QUnit.url( params );
		});
	}

	var toolbar = id(&quot;qunit-testrunner-toolbar&quot;);
	if ( toolbar ) {
		var filter = document.createElement(&quot;input&quot;);
		filter.type = &quot;checkbox&quot;;
		filter.id = &quot;qunit-filter-pass&quot;;
		addEvent( filter, &quot;click&quot;, function() {
			var ol = document.getElementById(&quot;qunit-tests&quot;);
			if ( filter.checked ) {
				ol.className = ol.className + &quot; hidepass&quot;;
			} else {
				var tmp = &quot; &quot; + ol.className.replace( &#x2F;[\n\t\r]&#x2F;g, &quot; &quot; ) + &quot; &quot;;
				ol.className = tmp.replace(&#x2F; hidepass &#x2F;, &quot; &quot;);
			}
			if ( defined.sessionStorage ) {
				if (filter.checked) {
					sessionStorage.setItem(&quot;qunit-filter-passed-tests&quot;, &quot;true&quot;);
				} else {
					sessionStorage.removeItem(&quot;qunit-filter-passed-tests&quot;);
				}
			}
		});
		if ( config.hidepassed || defined.sessionStorage &amp;&amp; sessionStorage.getItem(&quot;qunit-filter-passed-tests&quot;) ) {
			filter.checked = true;
			var ol = document.getElementById(&quot;qunit-tests&quot;);
			ol.className = ol.className + &quot; hidepass&quot;;
		}
		toolbar.appendChild( filter );

		var label = document.createElement(&quot;label&quot;);
		label.setAttribute(&quot;for&quot;, &quot;qunit-filter-pass&quot;);
		label.innerHTML = &quot;Hide passed tests&quot;;
		toolbar.appendChild( label );
	}

	var main = id(&#x27;qunit-fixture&#x27;);
	if ( main ) {
		config.fixture = main.innerHTML;
	}

	if (config.autostart) {
		QUnit.start();
	}
};

addEvent(window, &quot;load&quot;, QUnit.load);

&#x2F;&#x2F; addEvent(window, &quot;error&quot;) gives us a useless event object
window.onerror = function( message, file, line ) {
	if ( QUnit.config.current ) {
		ok( false, message + &quot;, &quot; + file + &quot;:&quot; + line );
	} else {
		test( &quot;global failure&quot;, function() {
			ok( false, message + &quot;, &quot; + file + &quot;:&quot; + line );
		});
	}
};

function done() {
	config.autorun = true;

	&#x2F;&#x2F; Log the last module results
	if ( config.currentModule ) {
		runLoggingCallbacks( &#x27;moduleDone&#x27;, QUnit, {
			name: config.currentModule,
			failed: config.moduleStats.bad,
			passed: config.moduleStats.all - config.moduleStats.bad,
			total: config.moduleStats.all
		} );
	}

	var banner = id(&quot;qunit-banner&quot;),
		tests = id(&quot;qunit-tests&quot;),
		runtime = +new Date - config.started,
		passed = config.stats.all - config.stats.bad,
		html = [
			&#x27;Tests completed in &#x27;,
			runtime,
			&#x27; milliseconds.&lt;br&#x2F;&gt;&#x27;,
			&#x27;&lt;span class=&quot;passed&quot;&gt;&#x27;,
			passed,
			&#x27;&lt;&#x2F;span&gt; tests of &lt;span class=&quot;total&quot;&gt;&#x27;,
			config.stats.all,
			&#x27;&lt;&#x2F;span&gt; passed, &lt;span class=&quot;failed&quot;&gt;&#x27;,
			config.stats.bad,
			&#x27;&lt;&#x2F;span&gt; failed.&#x27;
		].join(&#x27;&#x27;);

	if ( banner ) {
		banner.className = (config.stats.bad ? &quot;qunit-fail&quot; : &quot;qunit-pass&quot;);
	}

	if ( tests ) {
		id( &quot;qunit-testresult&quot; ).innerHTML = html;
	}

	if ( config.altertitle &amp;&amp; typeof document !== &quot;undefined&quot; &amp;&amp; document.title ) {
		&#x2F;&#x2F; show ✖ for good, ✔ for bad suite result in title
		&#x2F;&#x2F; use escape sequences in case file gets loaded with non-utf-8-charset
		document.title = [
			(config.stats.bad ? &quot;\u2716&quot; : &quot;\u2714&quot;),
			document.title.replace(&#x2F;^[\u2714\u2716] &#x2F;i, &quot;&quot;)
		].join(&quot; &quot;);
	}

	runLoggingCallbacks( &#x27;done&#x27;, QUnit, {
		failed: config.stats.bad,
		passed: passed,
		total: config.stats.all,
		runtime: runtime
	} );
}

function validTest( name ) {
	var filter = config.filter,
		run = false;

	if ( !filter ) {
		return true;
	}

	var not = filter.charAt( 0 ) === &quot;!&quot;;
	if ( not ) {
		filter = filter.slice( 1 );
	}

	if ( name.indexOf( filter ) !== -1 ) {
		return !not;
	}

	if ( not ) {
		run = true;
	}

	return run;
}

&#x2F;&#x2F; so far supports only Firefox, Chrome and Opera (buggy)
&#x2F;&#x2F; could be extended in the future to use something like https:&#x2F;&#x2F;github.com&#x2F;csnover&#x2F;TraceKit
function sourceFromStacktrace() {
	try {
		throw new Error();
	} catch ( e ) {
		if (e.stacktrace) {
			&#x2F;&#x2F; Opera
			return e.stacktrace.split(&quot;\n&quot;)[6];
		} else if (e.stack) {
			&#x2F;&#x2F; Firefox, Chrome
			return e.stack.split(&quot;\n&quot;)[4];
		} else if (e.sourceURL) {
			&#x2F;&#x2F; Safari, PhantomJS
			&#x2F;&#x2F; TODO sourceURL points at the &#x27;throw new Error&#x27; line above, useless
			&#x2F;&#x2F;return e.sourceURL + &quot;:&quot; + e.line;
		}
	}
}

function escapeInnerText(s) {
	if (!s) {
		return &quot;&quot;;
	}
	s = s + &quot;&quot;;
	return s.replace(&#x2F;[\&amp;&lt;&gt;]&#x2F;g, function(s) {
		switch(s) {
			case &quot;&amp;&quot;: return &quot;&amp;amp;&quot;;
			case &quot;&lt;&quot;: return &quot;&amp;lt;&quot;;
			case &quot;&gt;&quot;: return &quot;&amp;gt;&quot;;
			default: return s;
		}
	});
}

function synchronize( callback, last ) {
	config.queue.push( callback );

	if ( config.autorun &amp;&amp; !config.blocking ) {
		process(last);
	}
}

function process( last ) {
	var start = new Date().getTime();
	config.depth = config.depth ? config.depth + 1 : 1;

	while ( config.queue.length &amp;&amp; !config.blocking ) {
		if ( !defined.setTimeout || config.updateRate &lt;= 0 || ( ( new Date().getTime() - start ) &lt; config.updateRate ) ) {
			config.queue.shift()();
		} else {
			window.setTimeout( function(){
				process( last );
			}, 13 );
			break;
		}
	}
	config.depth--;
	if ( last &amp;&amp; !config.blocking &amp;&amp; !config.queue.length &amp;&amp; config.depth === 0 ) {
		done();
	}
}

function saveGlobal() {
	config.pollution = [];

	if ( config.noglobals ) {
		for ( var key in window ) {
			if ( !hasOwn.call( window, key ) ) {
				continue;
			}
			config.pollution.push( key );
		}
	}
}

function checkPollution( name ) {
	var old = config.pollution;
	saveGlobal();

	var newGlobals = diff( config.pollution, old );
	if ( newGlobals.length &gt; 0 ) {
		ok( false, &quot;Introduced global variable(s): &quot; + newGlobals.join(&quot;, &quot;) );
	}

	var deletedGlobals = diff( old, config.pollution );
	if ( deletedGlobals.length &gt; 0 ) {
		ok( false, &quot;Deleted global variable(s): &quot; + deletedGlobals.join(&quot;, &quot;) );
	}
}

&#x2F;&#x2F; returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
	var result = a.slice();
	for ( var i = 0; i &lt; result.length; i++ ) {
		for ( var j = 0; j &lt; b.length; j++ ) {
			if ( result[i] === b[j] ) {
				result.splice(i, 1);
				i--;
				break;
			}
		}
	}
	return result;
}

function fail(message, exception, callback) {
	if ( typeof console !== &quot;undefined&quot; &amp;&amp; console.error &amp;&amp; console.warn ) {
		console.error(message);
		console.error(exception);
		console.warn(callback.toString());

	} else if ( window.opera &amp;&amp; opera.postError ) {
		opera.postError(message, exception, callback.toString);
	}
}

function extend(a, b) {
	for ( var prop in b ) {
		if ( b[prop] === undefined ) {
			delete a[prop];

		&#x2F;&#x2F; Avoid &quot;Member not found&quot; error in IE8 caused by setting window.constructor
		} else if ( prop !== &quot;constructor&quot; || a !== window ) {
			a[prop] = b[prop];
		}
	}

	return a;
}

function addEvent(elem, type, fn) {
	if ( elem.addEventListener ) {
		elem.addEventListener( type, fn, false );
	} else if ( elem.attachEvent ) {
		elem.attachEvent( &quot;on&quot; + type, fn );
	} else {
		fn();
	}
}

function id(name) {
	return !!(typeof document !== &quot;undefined&quot; &amp;&amp; document &amp;&amp; document.getElementById) &amp;&amp;
		document.getElementById( name );
}

function registerLoggingCallback(key){
	return function(callback){
		config[key].push( callback );
	};
}

&#x2F;&#x2F; Supports deprecated method of completely overwriting logging callbacks
function runLoggingCallbacks(key, scope, args) {
	&#x2F;&#x2F;debugger;
	var callbacks;
	if ( QUnit.hasOwnProperty(key) ) {
		QUnit[key].call(scope, args);
	} else {
		callbacks = config[key];
		for( var i = 0; i &lt; callbacks.length; i++ ) {
			callbacks[i].call( scope, args );
		}
	}
}

&#x2F;&#x2F; Test for equality any JavaScript type.
&#x2F;&#x2F; Author: Philippe Rathé &lt;prathe@gmail.com&gt;
QUnit.equiv = function () {

	var innerEquiv; &#x2F;&#x2F; the real equiv function
	var callers = []; &#x2F;&#x2F; stack to decide between skip&#x2F;abort functions
	var parents = []; &#x2F;&#x2F; stack to avoiding loops from circular referencing

	&#x2F;&#x2F; Call the o related callback with the given arguments.
	function bindCallbacks(o, callbacks, args) {
		var prop = QUnit.objectType(o);
		if (prop) {
			if (QUnit.objectType(callbacks[prop]) === &quot;function&quot;) {
				return callbacks[prop].apply(callbacks, args);
			} else {
				return callbacks[prop]; &#x2F;&#x2F; or undefined
			}
		}
	}

	var callbacks = function () {

		&#x2F;&#x2F; for string, boolean, number and null
		function useStrictEquality(b, a) {
			if (b instanceof a.constructor || a instanceof b.constructor) {
				&#x2F;&#x2F; to catch short annotaion VS &#x27;new&#x27; annotation of a
				&#x2F;&#x2F; declaration
				&#x2F;&#x2F; e.g. var i = 1;
				&#x2F;&#x2F; var j = new Number(1);
				return a == b;
			} else {
				return a === b;
			}
		}

		return {
			&quot;string&quot; : useStrictEquality,
			&quot;boolean&quot; : useStrictEquality,
			&quot;number&quot; : useStrictEquality,
			&quot;null&quot; : useStrictEquality,
			&quot;undefined&quot; : useStrictEquality,

			&quot;nan&quot; : function(b) {
				return isNaN(b);
			},

			&quot;date&quot; : function(b, a) {
				return QUnit.objectType(b) === &quot;date&quot;
						&amp;&amp; a.valueOf() === b.valueOf();
			},

			&quot;regexp&quot; : function(b, a) {
				return QUnit.objectType(b) === &quot;regexp&quot;
						&amp;&amp; a.source === b.source &amp;&amp; &#x2F;&#x2F; the regex itself
						a.global === b.global &amp;&amp; &#x2F;&#x2F; and its modifers
													&#x2F;&#x2F; (gmi) ...
						a.ignoreCase === b.ignoreCase
						&amp;&amp; a.multiline === b.multiline;
			},

			&#x2F;&#x2F; - skip when the property is a method of an instance (OOP)
			&#x2F;&#x2F; - abort otherwise,
			&#x2F;&#x2F; initial === would have catch identical references anyway
			&quot;function&quot; : function() {
				var caller = callers[callers.length - 1];
				return caller !== Object &amp;&amp; typeof caller !== &quot;undefined&quot;;
			},

			&quot;array&quot; : function(b, a) {
				var i, j, loop;
				var len;

				&#x2F;&#x2F; b could be an object literal here
				if (!(QUnit.objectType(b) === &quot;array&quot;)) {
					return false;
				}

				len = a.length;
				if (len !== b.length) { &#x2F;&#x2F; safe and faster
					return false;
				}

				&#x2F;&#x2F; track reference to avoid circular references
				parents.push(a);
				for (i = 0; i &lt; len; i++) {
					loop = false;
					for (j = 0; j &lt; parents.length; j++) {
						if (parents[j] === a[i]) {
							loop = true;&#x2F;&#x2F; dont rewalk array
						}
					}
					if (!loop &amp;&amp; !innerEquiv(a[i], b[i])) {
						parents.pop();
						return false;
					}
				}
				parents.pop();
				return true;
			},

			&quot;object&quot; : function(b, a) {
				var i, j, loop;
				var eq = true; &#x2F;&#x2F; unless we can proove it
				var aProperties = [], bProperties = []; &#x2F;&#x2F; collection of
														&#x2F;&#x2F; strings

				&#x2F;&#x2F; comparing constructors is more strict than using
				&#x2F;&#x2F; instanceof
				if (a.constructor !== b.constructor) {
					return false;
				}

				&#x2F;&#x2F; stack constructor before traversing properties
				callers.push(a.constructor);
				&#x2F;&#x2F; track reference to avoid circular references
				parents.push(a);

				for (i in a) { &#x2F;&#x2F; be strict: don&#x27;t ensures hasOwnProperty
								&#x2F;&#x2F; and go deep
					loop = false;
					for (j = 0; j &lt; parents.length; j++) {
						if (parents[j] === a[i])
							loop = true; &#x2F;&#x2F; don&#x27;t go down the same path
											&#x2F;&#x2F; twice
					}
					aProperties.push(i); &#x2F;&#x2F; collect a&#x27;s properties

					if (!loop &amp;&amp; !innerEquiv(a[i], b[i])) {
						eq = false;
						break;
					}
				}

				callers.pop(); &#x2F;&#x2F; unstack, we are done
				parents.pop();

				for (i in b) {
					bProperties.push(i); &#x2F;&#x2F; collect b&#x27;s properties
				}

				&#x2F;&#x2F; Ensures identical properties name
				return eq
						&amp;&amp; innerEquiv(aProperties.sort(), bProperties
								.sort());
			}
		};
	}();

	innerEquiv = function() { &#x2F;&#x2F; can take multiple arguments
		var args = Array.prototype.slice.apply(arguments);
		if (args.length &lt; 2) {
			return true; &#x2F;&#x2F; end transition
		}

		return (function(a, b) {
			if (a === b) {
				return true; &#x2F;&#x2F; catch the most you can
			} else if (a === null || b === null || typeof a === &quot;undefined&quot;
					|| typeof b === &quot;undefined&quot;
					|| QUnit.objectType(a) !== QUnit.objectType(b)) {
				return false; &#x2F;&#x2F; don&#x27;t lose time with error prone cases
			} else {
				return bindCallbacks(a, callbacks, [ b, a ]);
			}

			&#x2F;&#x2F; apply transition with (1..n) arguments
		})(args[0], args[1])
				&amp;&amp; arguments.callee.apply(this, args.splice(1,
						args.length - 1));
	};

	return innerEquiv;

}();

&#x2F;**
 * jsDump Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com |
 * http:&#x2F;&#x2F;flesler.blogspot.com Licensed under BSD
 * (http:&#x2F;&#x2F;www.opensource.org&#x2F;licenses&#x2F;bsd-license.php) Date: 5&#x2F;15&#x2F;2008
 *
 * @projectDescription Advanced and extensible data dumping for Javascript.
 * @version 1.0.0
 * @author Ariel Flesler
 * @link {http:&#x2F;&#x2F;flesler.blogspot.com&#x2F;2008&#x2F;05&#x2F;jsdump-pretty-dump-of-any-javascript.html}
 *&#x2F;
QUnit.jsDump = (function() {
	function quote( str ) {
		return &#x27;&quot;&#x27; + str.toString().replace(&#x2F;&quot;&#x2F;g, &#x27;\\&quot;&#x27;) + &#x27;&quot;&#x27;;
	};
	function literal( o ) {
		return o + &#x27;&#x27;;
	};
	function join( pre, arr, post ) {
		var s = jsDump.separator(),
			base = jsDump.indent(),
			inner = jsDump.indent(1);
		if ( arr.join )
			arr = arr.join( &#x27;,&#x27; + s + inner );
		if ( !arr )
			return pre + post;
		return [ pre, inner + arr, base + post ].join(s);
	};
	function array( arr, stack ) {
		var i = arr.length, ret = Array(i);
		this.up();
		while ( i-- )
			ret[i] = this.parse( arr[i] , undefined , stack);
		this.down();
		return join( &#x27;[&#x27;, ret, &#x27;]&#x27; );
	};

	var reName = &#x2F;^function (\w+)&#x2F;;

	var jsDump = {
		parse:function( obj, type, stack ) { &#x2F;&#x2F;type is used mostly internally, you can fix a (custom)type in advance
			stack = stack || [ ];
			var parser = this.parsers[ type || this.typeOf(obj) ];
			type = typeof parser;
			var inStack = inArray(obj, stack);
			if (inStack != -1) {
				return &#x27;recursion(&#x27;+(inStack - stack.length)+&#x27;)&#x27;;
			}
			&#x2F;&#x2F;else
			if (type == &#x27;function&#x27;)  {
					stack.push(obj);
					var res = parser.call( this, obj, stack );
					stack.pop();
					return res;
			}
			&#x2F;&#x2F; else
			return (type == &#x27;string&#x27;) ? parser : this.parsers.error;
		},
		typeOf:function( obj ) {
			var type;
			if ( obj === null ) {
				type = &quot;null&quot;;
			} else if (typeof obj === &quot;undefined&quot;) {
				type = &quot;undefined&quot;;
			} else if (QUnit.is(&quot;RegExp&quot;, obj)) {
				type = &quot;regexp&quot;;
			} else if (QUnit.is(&quot;Date&quot;, obj)) {
				type = &quot;date&quot;;
			} else if (QUnit.is(&quot;Function&quot;, obj)) {
				type = &quot;function&quot;;
			} else if (typeof obj.setInterval !== undefined &amp;&amp; typeof obj.document !== &quot;undefined&quot; &amp;&amp; typeof obj.nodeType === &quot;undefined&quot;) {
				type = &quot;window&quot;;
			} else if (obj.nodeType === 9) {
				type = &quot;document&quot;;
			} else if (obj.nodeType) {
				type = &quot;node&quot;;
			} else if (
				&#x2F;&#x2F; native arrays
				toString.call( obj ) === &quot;[object Array]&quot; ||
				&#x2F;&#x2F; NodeList objects
				( typeof obj.length === &quot;number&quot; &amp;&amp; typeof obj.item !== &quot;undefined&quot; &amp;&amp; ( obj.length ? obj.item(0) === obj[0] : ( obj.item( 0 ) === null &amp;&amp; typeof obj[0] === &quot;undefined&quot; ) ) )
			) {
				type = &quot;array&quot;;
			} else {
				type = typeof obj;
			}
			return type;
		},
		separator:function() {
			return this.multiline ?	this.HTML ? &#x27;&lt;br &#x2F;&gt;&#x27; : &#x27;\n&#x27; : this.HTML ? &#x27;&amp;nbsp;&#x27; : &#x27; &#x27;;
		},
		indent:function( extra ) {&#x2F;&#x2F; extra can be a number, shortcut for increasing-calling-decreasing
			if ( !this.multiline )
				return &#x27;&#x27;;
			var chr = this.indentChar;
			if ( this.HTML )
				chr = chr.replace(&#x2F;\t&#x2F;g,&#x27;   &#x27;).replace(&#x2F; &#x2F;g,&#x27;&amp;nbsp;&#x27;);
			return Array( this._depth_ + (extra||0) ).join(chr);
		},
		up:function( a ) {
			this._depth_ += a || 1;
		},
		down:function( a ) {
			this._depth_ -= a || 1;
		},
		setParser:function( name, parser ) {
			this.parsers[name] = parser;
		},
		&#x2F;&#x2F; The next 3 are exposed so you can use them
		quote:quote,
		literal:literal,
		join:join,
		&#x2F;&#x2F;
		_depth_: 1,
		&#x2F;&#x2F; This is the list of parsers, to modify them, use jsDump.setParser
		parsers:{
			window: &#x27;[Window]&#x27;,
			document: &#x27;[Document]&#x27;,
			error:&#x27;[ERROR]&#x27;, &#x2F;&#x2F;when no parser is found, shouldn&#x27;t happen
			unknown: &#x27;[Unknown]&#x27;,
			&#x27;null&#x27;:&#x27;null&#x27;,
			&#x27;undefined&#x27;:&#x27;undefined&#x27;,
			&#x27;function&#x27;:function( fn ) {
				var ret = &#x27;function&#x27;,
					name = &#x27;name&#x27; in fn ? fn.name : (reName.exec(fn)||[])[1];&#x2F;&#x2F;functions never have name in IE
				if ( name )
					ret += &#x27; &#x27; + name;
				ret += &#x27;(&#x27;;

				ret = [ ret, QUnit.jsDump.parse( fn, &#x27;functionArgs&#x27; ), &#x27;){&#x27;].join(&#x27;&#x27;);
				return join( ret, QUnit.jsDump.parse(fn,&#x27;functionCode&#x27;), &#x27;}&#x27; );
			},
			array: array,
			nodelist: array,
			arguments: array,
			object:function( map, stack ) {
				var ret = [ ];
				QUnit.jsDump.up();
				for ( var key in map ) {
				    var val = map[key];
					ret.push( QUnit.jsDump.parse(key,&#x27;key&#x27;) + &#x27;: &#x27; + QUnit.jsDump.parse(val, undefined, stack));
                }
				QUnit.jsDump.down();
				return join( &#x27;{&#x27;, ret, &#x27;}&#x27; );
			},
			node:function( node ) {
				var open = QUnit.jsDump.HTML ? &#x27;&amp;lt;&#x27; : &#x27;&lt;&#x27;,
					close = QUnit.jsDump.HTML ? &#x27;&amp;gt;&#x27; : &#x27;&gt;&#x27;;

				var tag = node.nodeName.toLowerCase(),
					ret = open + tag;

				for ( var a in QUnit.jsDump.DOMAttrs ) {
					var val = node[QUnit.jsDump.DOMAttrs[a]];
					if ( val )
						ret += &#x27; &#x27; + a + &#x27;=&#x27; + QUnit.jsDump.parse( val, &#x27;attribute&#x27; );
				}
				return ret + close + open + &#x27;&#x2F;&#x27; + tag + close;
			},
			functionArgs:function( fn ) {&#x2F;&#x2F;function calls it internally, it&#x27;s the arguments part of the function
				var l = fn.length;
				if ( !l ) return &#x27;&#x27;;

				var args = Array(l);
				while ( l-- )
					args[l] = String.fromCharCode(97+l);&#x2F;&#x2F;97 is &#x27;a&#x27;
				return &#x27; &#x27; + args.join(&#x27;, &#x27;) + &#x27; &#x27;;
			},
			key:quote, &#x2F;&#x2F;object calls it internally, the key part of an item in a map
			functionCode:&#x27;[code]&#x27;, &#x2F;&#x2F;function calls it internally, it&#x27;s the content of the function
			attribute:quote, &#x2F;&#x2F;node calls it internally, it&#x27;s an html attribute value
			string:quote,
			date:quote,
			regexp:literal, &#x2F;&#x2F;regex
			number:literal,
			&#x27;boolean&#x27;:literal
		},
		DOMAttrs:{&#x2F;&#x2F;attributes to dump from nodes, name=&gt;realName
			id:&#x27;id&#x27;,
			name:&#x27;name&#x27;,
			&#x27;class&#x27;:&#x27;className&#x27;
		},
		HTML:false,&#x2F;&#x2F;if true, entities are escaped ( &lt;, &gt;, \t, space and \n )
		indentChar:&#x27;  &#x27;,&#x2F;&#x2F;indentation unit
		multiline:true &#x2F;&#x2F;if true, items in a collection, are separated by a \n, else just a space.
	};

	return jsDump;
})();

&#x2F;&#x2F; from Sizzle.js
function getText( elems ) {
	var ret = &quot;&quot;, elem;

	for ( var i = 0; elems[i]; i++ ) {
		elem = elems[i];

		&#x2F;&#x2F; Get the text from text nodes and CDATA nodes
		if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
			ret += elem.nodeValue;

		&#x2F;&#x2F; Traverse everything else, except comment nodes
		} else if ( elem.nodeType !== 8 ) {
			ret += getText( elem.childNodes );
		}
	}

	return ret;
};

&#x2F;&#x2F;from jquery.js
function inArray( elem, array ) {
	if ( array.indexOf ) {
		return array.indexOf( elem );
	}

	for ( var i = 0, length = array.length; i &lt; length; i++ ) {
		if ( array[ i ] === elem ) {
			return i;
		}
	}

	return -1;
}

&#x2F;*
 * Javascript Diff Algorithm
 *  By John Resig (http:&#x2F;&#x2F;ejohn.org&#x2F;)
 *  Modified by Chu Alan &quot;sprite&quot;
 *
 * Released under the MIT license.
 *
 * More Info:
 *  http:&#x2F;&#x2F;ejohn.org&#x2F;projects&#x2F;javascript-diff-algorithm&#x2F;
 *
 * Usage: QUnit.diff(expected, actual)
 *
 * QUnit.diff(&quot;the quick brown fox jumped over&quot;, &quot;the quick fox jumps over&quot;) == &quot;the  quick &lt;del&gt;brown &lt;&#x2F;del&gt; fox &lt;del&gt;jumped &lt;&#x2F;del&gt;&lt;ins&gt;jumps &lt;&#x2F;ins&gt; over&quot;
 *&#x2F;
QUnit.diff = (function() {
	function diff(o, n) {
		var ns = {};
		var os = {};

		for (var i = 0; i &lt; n.length; i++) {
			if (ns[n[i]] == null)
				ns[n[i]] = {
					rows: [],
					o: null
				};
			ns[n[i]].rows.push(i);
		}

		for (var i = 0; i &lt; o.length; i++) {
			if (os[o[i]] == null)
				os[o[i]] = {
					rows: [],
					n: null
				};
			os[o[i]].rows.push(i);
		}

		for (var i in ns) {
			if ( !hasOwn.call( ns, i ) ) {
				continue;
			}
			if (ns[i].rows.length == 1 &amp;&amp; typeof(os[i]) != &quot;undefined&quot; &amp;&amp; os[i].rows.length == 1) {
				n[ns[i].rows[0]] = {
					text: n[ns[i].rows[0]],
					row: os[i].rows[0]
				};
				o[os[i].rows[0]] = {
					text: o[os[i].rows[0]],
					row: ns[i].rows[0]
				};
			}
		}

		for (var i = 0; i &lt; n.length - 1; i++) {
			if (n[i].text != null &amp;&amp; n[i + 1].text == null &amp;&amp; n[i].row + 1 &lt; o.length &amp;&amp; o[n[i].row + 1].text == null &amp;&amp;
			n[i + 1] == o[n[i].row + 1]) {
				n[i + 1] = {
					text: n[i + 1],
					row: n[i].row + 1
				};
				o[n[i].row + 1] = {
					text: o[n[i].row + 1],
					row: i + 1
				};
			}
		}

		for (var i = n.length - 1; i &gt; 0; i--) {
			if (n[i].text != null &amp;&amp; n[i - 1].text == null &amp;&amp; n[i].row &gt; 0 &amp;&amp; o[n[i].row - 1].text == null &amp;&amp;
			n[i - 1] == o[n[i].row - 1]) {
				n[i - 1] = {
					text: n[i - 1],
					row: n[i].row - 1
				};
				o[n[i].row - 1] = {
					text: o[n[i].row - 1],
					row: i - 1
				};
			}
		}

		return {
			o: o,
			n: n
		};
	}

	return function(o, n) {
		o = o.replace(&#x2F;\s+$&#x2F;, &#x27;&#x27;);
		n = n.replace(&#x2F;\s+$&#x2F;, &#x27;&#x27;);
		var out = diff(o == &quot;&quot; ? [] : o.split(&#x2F;\s+&#x2F;), n == &quot;&quot; ? [] : n.split(&#x2F;\s+&#x2F;));

		var str = &quot;&quot;;

		var oSpace = o.match(&#x2F;\s+&#x2F;g);
		if (oSpace == null) {
			oSpace = [&quot; &quot;];
		}
		else {
			oSpace.push(&quot; &quot;);
		}
		var nSpace = n.match(&#x2F;\s+&#x2F;g);
		if (nSpace == null) {
			nSpace = [&quot; &quot;];
		}
		else {
			nSpace.push(&quot; &quot;);
		}

		if (out.n.length == 0) {
			for (var i = 0; i &lt; out.o.length; i++) {
				str += &#x27;&lt;del&gt;&#x27; + out.o[i] + oSpace[i] + &quot;&lt;&#x2F;del&gt;&quot;;
			}
		}
		else {
			if (out.n[0].text == null) {
				for (n = 0; n &lt; out.o.length &amp;&amp; out.o[n].text == null; n++) {
					str += &#x27;&lt;del&gt;&#x27; + out.o[n] + oSpace[n] + &quot;&lt;&#x2F;del&gt;&quot;;
				}
			}

			for (var i = 0; i &lt; out.n.length; i++) {
				if (out.n[i].text == null) {
					str += &#x27;&lt;ins&gt;&#x27; + out.n[i] + nSpace[i] + &quot;&lt;&#x2F;ins&gt;&quot;;
				}
				else {
					var pre = &quot;&quot;;

					for (n = out.n[i].row + 1; n &lt; out.o.length &amp;&amp; out.o[n].text == null; n++) {
						pre += &#x27;&lt;del&gt;&#x27; + out.o[n] + oSpace[n] + &quot;&lt;&#x2F;del&gt;&quot;;
					}
					str += &quot; &quot; + out.n[i].text + nSpace[i] + pre;
				}
			}
		}

		return str;
	};
})();

})(this);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
